<html>
<head>
<style>
* {margin: 0;padding: 0;}
.grid {
    border: 1px solid red;
    position: relative;
    min-height: 200px;
}
.cell {
    position: absolute;
    height: 100px;
    text-align: center;
    vertical-align: center;
    box-sizing: border-box;
    padding: 10px;
}
.cell:before {
    content: '';
    border: 1px solid orange;
    position: absolute;
    top: 10px;
    left: 10px;
    bottom: 10px;
    right: 10px;
    background: url(https://www.google.com.sg/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png) no-repeat center center;
    -webkit-background-size: contain;
    background-size: contain;
}
.cell span {
    display: block;
    position: absolute;
    bottom: 10px;
    left: 10px;
    right: 10px;
    color: #eee;
    text-shadow: 0 0 5px #000;
    background: rgba(0,0,0,.6);
    padding: 4px;
    font-size: 120%;
}
</style>

<script src="bower_components/jquery/dist/jquery.min.js"></script>
<script src="bower_components/jquery.easing/js/jquery.easing.min.js"></script>
<script>
var gh;
$(document).ready(function()
{
    gh = new gridHandler(
    {
        grid: '.grid',
        cells: '.cell',
        cellHeight: 100,
        cellsPerRow: 7,
        animationSpeed: 1200,
        animationEasing: 'easeOutElastic',
        updateGridHeight: true,
        breakpoints:
        {
            1199:
            {
                cellsPerRow: 5,
                cellHeight: 100
            },
            767:
            {
                cellsPerRow: 4,
                cellHeight: 130
            },
            479:
            {
                cellsPerRow: 2,
                cellHeight: 160
            },
        }
    });
});


/**
 * Helper function.
 * Creates a matrix of the given size and fill each cell with a default value.
 *
 * @param      {number}  cols          The columns number.
 * @param      {number}  rows          The rows number.
 * @param      {mixed}   defaultValue  The default value for each cell.
 * @return     {Array}   the generated matrix.
 */
function matrix( cols, rows, defaultValue)
{
    for (var i = 0, arr = []; i < rows; i++)
    {
        arr.push([]);// Creates an empty line.
        arr[i].push(new Array(cols));// Adds cols to the empty line.
        for (var j=0; j < cols; j++) arr[i][j] = defaultValue;// Initializes.
    }

    return arr;
}


var gridHandler = function(options)
{
    // Private vars.
    var self = this, grid, cells, cellsNum, cellWidth, cellHeight,
        defaults =
        {
            grid: $('#grid'),// The container of the cells.
            cells: $('.cell'),// The cells to render / place / filter.
            cellsPerRow: 7,
            cellHeight: 100,// Cell height in pixels.
            animationSpeed: 600,
            animationEasing: 'easeOutQuad',
            updateGridHeight: true,
            /* Breakpoints (from desktop to mobile) to have a different behavior according to the device screen width.
            Example of use:
            breakpoints:
            {
                1199:
                {
                    cellsPerRow: 5
                },
                767:
                {
                    cellsPerRow: 4
                },
                479:
                {
                    cellsPerRow: 3
                },
            }*/
            breakpoints: []
        },
        /**
         * Internal matrix class to handle all the calculations.
         * Don't forget the optimization is very important as we trigger the redraw() function on resize.
         * Represent the grid as a matrix like:
         * [0 0 0 0
         *  0 0 0 0
         *  0 0 0 0
         *  0 0 0 0].
         */
        gridMatrix =
        {
            matrix: [],// The matrix in use for placing cells.
            cols: 0,// Cache the cols number for optimization as used few times in this class.
            rows: 0,// Cache the rows number for optimization as used few times in this class.
            emptyCells: [],// Index the empty cells for faster results.

            /**
             * Creates the matrix with the specified dimensions.
             * And fill each cell with Null to represent cell availability.
             *
             * @return     {Object}  { description_of_the_return_value }
             */
            init: function()
            {
                this.emptyCells = [];
                this.cols = options.cellsPerRow;
                this.rows = Math.ceil(cellsNum / this.cols);
                this.matrix = matrix(this.cols, this.rows, null);

                // First index the whole matrix cells in this.emptyCells array as every cell is empty.
                // Indexing the empty cells for optimization.
                for (var row = 0; row < this.rows; row++) {
                    for (var col = 0; col < options.cellsPerRow; col++) {
                        this.emptyCells.push(row + "." + col);// Creating decimal format to benefit from the simple numeric sorting.
                    }
                }
                return this;
            },

            /**
             * Adds an empty cell to the quick index array - for optimization.
             *
             * @param {string}  position:  The [x, y] coordinates in matrix.
             */
            addEmptyCell: function(position)
            {
                this.emptyCells.push(position[1] + '.' + position[0]);
                this.emptyCells.sort(function(a,b){return a-b});
            },

            /**
             * Removes an empty cell.
             *
             * @param {string}  position:  The [x, y] coordinates in matrix.
             */
            removeEmptyCell: function(position)
            {
                // IE8-:
                // for (var cell = 0, l = this.emptyCells.length; cell < l; cell++) {
                //     if (this.emptyCells[cell] === position[1] + ',' + position[0]) this.emptyCells.splice(cell, 1);
                // }
                // Modern browsers:
                var index = this.emptyCells.indexOf(position[1] + '.' + position[0]);
                if (index > -1) this.emptyCells.splice(index, 1);
                this.emptyCells.sort(function(a,b){return a-b});
            },

            /**
             * Inject the cell content in matrix.
             * The matrix here won't contain any HTML it will only hold the given DOM cell index.
             *
             * @param  {string}  cellContent:  The cell content
             * @param  {string}  dimension:    The dimension
             * @param  {string}  position:     The [x, y] coordinates in matrix.
             * @return {string}  { description_of_the_return_value }
             */
            inject: function(cellContent, dimension, position)
            {
                // Store the dimension (in units) of the cell we want to inject in matrix.
                var dim = {w: dimension[0], h: dimension[1]},
                    fillCellsWidth = dim.w,
                    fillCellsHeight = dim.h;

                // At what matrix position do we inject the cell content.
                if (position === undefined) position = this.getNextEmptyCell();

                // Inject when a matrix position where cell content is fitting is found.
                while (!this.canFit(dimension, position))
                {
                    position = this.getNextCell(position);
                }
                // Now that a place is found in matrix to fit the content fill the needed matrix cells.
                var x = position[0], y = position[1];
                while (fillCellsWidth > 0)
                {
                    this.matrix[y][x] = cellContent;
                    this.removeEmptyCell([x, y]);
                    fillCellsHeight = dim.h - 1;

                    while (fillCellsHeight > 0)
                    {
                        y++;
                        this.matrix[y][x] = cellContent;
                        this.removeEmptyCell([x, y]);
                        fillCellsHeight--;
                    }
                    fillCellsWidth--;

                    x++;
                }

                return position;
            },

            /**
             * Gets the next empty cell.
             *
             * @return {Array}  The next empty cell [x, y] coordinates in matrix.
             */
            getNextEmptyCell: function()
            {
                if (!this.emptyCells.length) return this.addNewRow();

                var yx = this.emptyCells[0].split('.');
                // console.log('getNextEmptyCell', this.emptyCells, 'returning first empty cell: [x:'+yx[1]+', y:'+yx[0]+']', [parseInt(yx[1]), parseInt(yx[0])]);
                return [parseInt(yx[1]), parseInt(yx[0])];

            },

            /**
             * Gets the next cell whether it is empty or not.
             *
             * @param  {Array}   position:  The [x, y] coordinates in matrix.
             * @return {Array}  The next cell [x, y] coordinates in matrix.
             */
            getNextCell: function(position)
            {
                if (position === undefined) position = [0, 0];
                // console.log('getNextCell returns next existing cell position:', this.matrix[position[1]][position[0] + 1] !== undefined ? [position[0] + 1, position[1]] : [0, position[1] + 1])
                                                                               // : [0, position[1] + 1])

                // Look for a cell on the right of the current one, if none take the first one of the following row.
                return this.matrix[position[1]][position[0] + 1] !== undefined ? [position[0] + 1, position[1]] : [0, position[1] + 1];
            },

            /**
             * Adds a new row to the matrix.
             */
            addNewRow: function()
            {
                this.matrix.push(matrix(this.cols, 1, null)[0]);
                this.rows++;
                for (var i = 0; i < this.cols; i++) this.addEmptyCell([i, this.rows - 1]);

                // console.log('adding a new row.', this.emptyCells, this.rows)
                return [0, this.rows - 1];
            },

            /**
             * Determines if cell is empty.
             *
             * @param  {Array}    position:  The [x, y] coordinates in matrix.
             * @return     {boolean}  True if cell is empty, False otherwise.
             */
            isCellEmpty: function(position)
            {
                if (this.matrix[position[1]] === undefined)
                {
                    this.addNewRow();
                    return true;
                }
                // console.log('checking if cell empty:', this.matrix[position[1]][position[0]] === null);
                return this.matrix[position[1]][position[0]] === null;
            },

            /**
             * Determines ability to fit.
             *
             * @param      {number}   dimension  The dimension
             * @param      {Array}  position:  The [x, y] coordinates in matrix.
             * @return     {boolean}  True if able to fit, False otherwise.
             */
            canFit: function(dimension, position)
            {
                var w = dimension[0],
                    h = dimension[1],
                    x = position[0],
                    y = position[1],
                    canFitWidth = 0,
                    canFitHeight = 0;

                // If the cell exists (different of undefined) and is empty.
                for (var i = x; i < x + w; i++) if (this.isCellEmpty([i, y]) === true) {canFitWidth++;}
                for (var j = y; j < y + h; j++) if (this.isCellEmpty([x, j]) === true) {canFitHeight++;}

                // console.log('cell with dimension [w: '+w+', h: '+h+'] can fit at position [x:'+x+', y:'+y+']', (canFitWidth >= w && canFitHeight >= h))
                return canFitWidth >= w && canFitHeight >= h;
            }
        };


    // Public vars.
    self.options = options;
    // Uncomment for debugging.
    // self.gridMatrix = gridMatrix;


    /**
     * Loop through each DOM element in the 'cells' collection and place them in the created matrix according to availability.
     */
    self.fillMatrix = function()
    {
        // Create the matrix to the specified dimensions.
        gridMatrix.init();

        cells.each(function(i, cell)
        {
            cell = $(cell);
            var unitWidth = cell.data('width') || 1,
                unitHeight = cell.data('height') || 1,
                matrixPosition = gridMatrix.inject(i, [Math.min(unitWidth, options.cellsPerRow), unitHeight]);

            // Remember the matrix position in DOM pure js element itself.
            cell[0].matrixPosition = {x: matrixPosition[0], y: matrixPosition[1]};
        });
    };


    /**
     * { function_description }
     */
    self.render = function()
    {
        cells.each(function(i, cell)
        {
            cell = $(cell);
            // If reduce screen until a cell width doesn't fit grid width then constrain it to the grid width.
            var unitWidth = Math.min(cell.data('width'), options.cellsPerRow) || 1,
                unitHeight = cell.data('height') || 1;

            cell.stop(true, true).animate(
            {
                width: (cellWidth * unitWidth) + '%',
                height: cellHeight * unitHeight,
                top: cell[0].matrixPosition.y * cellHeight,
                left: (cell[0].matrixPosition.x * 100 / options.cellsPerRow) + '%',
            }, options.animationSpeed, options.animationEasing);
        });

        // After the cells positionning the grid height might have changed. Update if updateGridHeight is set to true.
        if (options.updateGridHeight) grid.height(gridMatrix.rows * options.cellHeight);
    };

    /**
     * update params.
     *
     * @param      {<type>}  params  The parameters
     */
    self.updateParams = function(params)
    {
        // Merge current settings and overriding new ones given as parameter.
        options = $.extend(options, params);

        cellWidth = 100 / options.cellsPerRow;
        cellHeight = options.cellHeight;
    };

    /**
     * { function_description }
     */
    self.redraw = function()
    {
        self.fillMatrix();
        self.render();
    };

    /**
     * { function_description }
     */
    /* V1.
    self.bindEvents = function()
    {
        var initConfig = options,
            currentBreakpoint,
            breakpointsArray = [],
            breakpointsNum = 0;// cache value outside of resize event for optimization.

        for (var breakpoint in options.breakpoints) breakpointsArray.push(breakpoint);
        breakpointsNum = breakpointsArray.length;

        if (breakpointsArray.length)
        {
            // NATURAL numeric ascendant sorting.
            breakpointsArray.sort(function(a, b){return a - b});

            $(window).on('resize', function()
            {
                var params = {},
                    screenWidth = this.innerWidth,
                    needRedraw = false;


                for (var breakpointIndex = 0; breakpointIndex < breakpointsNum; breakpointIndex++)
                {
                    var breakpoint = breakpointsArray[breakpointIndex];

                    // Since the array of breakpoint is asc-sorted for sure, from lowest value to biggest value,
                    // then break loop when screenwidth lesser than or equal this breakpoint value.
                    if (screenWidth <= breakpoint)
                    {
                        // Apply the settings of the breakpoint being reached by current screen width.
                        params = options.breakpoints[breakpoint];

                        // Yet another optimization to avoid too frequent redraws if same state.
                        needRedraw = currentBreakpoint !== breakpoint;
                        currentBreakpoint = breakpoint;
                        console.log(currentBreakpoint)
                        break;
                    }
                    else// largest config, take original configs.
                    {
                        needRedraw = currentBreakpoint !== breakpoint;
                        params = initConfig;
                        currentBreakpoint = 1000000;
                    }
                }

                // Only redraw if current breakpoint has changed.
                if (needRedraw)
                {
                    self.updateParams(params);
                    self.redraw();
                }
            });
        }
    };*/
    /* V2.
    self.bindEvents = function()
    {
        var initConfig = options,
            currentBreakpoint,
            breakpointsArray = [],
            breakpointsNum = 0,// cache value outside of resize event for optimization.
            hasBreakpoint2, hasBreakpoint3, hasBreakpoint4, hasBreakpoint5, hasBreakpoint6;

        for (var breakpoint in options.breakpoints) breakpointsArray.push(breakpoint);
        breakpointsNum = breakpointsArray.length;
        hasBreakpoint2 = breakpointsNum <= 1;
        hasBreakpoint3 = breakpointsNum <= 2;
        hasBreakpoint4 = breakpointsNum <= 3;
        hasBreakpoint5 = breakpointsNum <= 4;
        hasBreakpoint6 = breakpointsNum <= 5;



        if (breakpointsArray.length)
        {
            // NATURAL numeric ascendant sorting.
            breakpointsArray.sort(function(a, b){return a - b});

            $(window).on('resize', function()
            {
                var params = {},
                    screenWidth = this.innerWidth,
                    largestWidth = false,
                    breakpointIndex = 0,
                    needRedraw = false;

                if (screenWidth <= breakpointsArray[0]) breakpointIndex = 0;
                else if (hasBreakpoint2 && screenWidth <= breakpointsArray[1]) breakpointIndex = 1;
                else if (hasBreakpoint3 && screenWidth <= breakpointsArray[2]) breakpointIndex = 2;
                else if (hasBreakpoint4 && screenWidth <= breakpointsArray[3]) breakpointIndex = 3;
                else if (hasBreakpoint5 && screenWidth <= breakpointsArray[4]) breakpointIndex = 4;
                else if (hasBreakpoint6 && screenWidth <= breakpointsArray[5]) breakpointIndex = 5;
                else largestWidth = true;// largest config, take original configs.

                needRedraw = currentBreakpoint !== breakpointsArray[breakpointIndex];
                currentBreakpoint = largestWidth ? 'largest' : breakpointsArray[breakpointIndex];
                params = largestWidth ? initConfig : options.breakpoints[currentBreakpoint];
                console.log(currentBreakpoint)


                // Only redraw if current breakpoint has changed.
                if (needRedraw)
                {
                    self.updateParams(params);
                    self.redraw();
                }
            });
        }
    };*/
    // v3.
    self.bindEvents = function()
    {
        if (!$.isEmptyObject(options.breakpoints))
        {
            var initConfig = options,
                currentBreakpoint,
                breakpointsArray = [],
                breakpointsNum;

            // Convert to breakpoints object an array for sorting.
            for (var breakpoint in options.breakpoints) breakpointsArray.push(breakpoint * 1);
            breakpointsNum = breakpointsArray.length;

            // NATURAL numeric ascendant sorting.
            breakpointsArray.sort(function(a, b){return a - b});


            $(window).on('resize', function()
            {
                var params = {},
                    screenWidth = this.innerWidth,
                    tmpBp = [],
                    newBreakpoint;

                // Best optimized code possible:
                // Way faster than for loop on given breakpoints.
                // Also faster than a series of if / else if.
                // The idea is to have an array of breakpoints and add the current screenWidth in it and ASC sort the array.
                // Then locate the position of the screenWidth in array and get the breakpoint just above to get its config.
                tmpBp = breakpointsArray.slice(0);// Clone array.
                tmpBp.push(screenWidth);// Add screenWidth to the array.
                tmpBp.sort(function(a, b){return a - b});// Sort NATURAL numbers ASC.
                var i = tmpBp.indexOf(screenWidth);// Get the position of screenWidth.

                // If position is last, breakpointsArray[i] won't exist => just take the initial config.
                newBreakpoint = i === breakpointsNum ? 'largest' : breakpointsArray[i];


                // Only redraw if current breakpoint has changed.
                if (newBreakpoint !== currentBreakpoint)
                {
                    currentBreakpoint = newBreakpoint;

                    // Apply params.
                    params = i === breakpointsNum ? initConfig : options.breakpoints[currentBreakpoint];
                    self.updateParams(params);
                    self.redraw();
                }
            });
        }
    };

    /**
     * Show or hide the given collection of cells
     *
     * @param      {jQuery Collection or selector string}   cellsToToggle  The cells to toggle
     * @param      {boolean}  hide           whether to show or hide the collection of cells.
     */
    self.filter = function(cellsToToggle, hide, toggleAllOthers)
    {
        if (toggleAllOthers) $(cellsToToggle)[hide ? 'hide' : 'show']().siblings(options.cells)[hide ? 'show' : 'hide']();
        else $(cellsToToggle)[hide ? 'hide' : 'show']();

        options.cells = '.cell:visible';
        cells = $(options.cells);
        cellsNum = cells.length;
    }

    /**
     * { function_description }
     */
    self.init = function()
    {
        // Merge default settings and overriding options given as parameter.
        options = $.extend(defaults, options);

        // Init the core vars.
        grid = $(options.grid);
        cells = $(options.cells);
        cellsNum = cells.length;
        cellWidth = 100 / options.cellsPerRow;
        cellHeight = options.cellHeight;

        // First set the grid approximate height before calculating the cells position.
        // After the cells placing the grid height will probably be different.
        grid.css('height', Math.ceil(cellsNum / options.cellsPerRow) * options.cellHeight);


        self.bindEvents();
        self.fillMatrix();
        self.render();

        // Trigger the init custom event (for a possible callback) once the grid is initialized.
        grid.trigger('init').addClass('ready');
    }();
};
</script>
</head>
<body>
    <div class="grid">
        <div class="cell" data-width="1" data-height="4"><span>0</span></div>
        <div class="cell" data-width="1" data-height="1"><span>1</span></div>
        <div class="cell" data-width="2" data-height="1"><span>2</span></div>
        <div class="cell" data-width="2" data-height="1"><span>3</span></div>
        <div class="cell" data-width="2" data-height="1"><span>4</span></div>
        <div class="cell" data-width="2" data-height="1"><span>5</span></div>
        <div class="cell" data-width="3" data-height="1"><span>6</span></div>
        <div class="cell" data-width="1" data-height="1"><span>7</span></div>
        <div class="cell" data-width="1" data-height="1"><span>8</span></div>
        <div class="cell" data-width="1" data-height="2"><span>9</span></div>
        <div class="cell" data-width="1" data-height="1"><span>10</span></div>
        <div class="cell" data-width="1" data-height="1"><span>11</span></div>
        <div class="cell" data-width="1" data-height="1"><span>12</span></div>
        <div class="cell" data-width="1" data-height="1"><span>13</span></div>
        <div class="cell" data-width="1" data-height="1"><span>14</span></div>
        <div class="cell" data-width="1" data-height="1"><span>15</span></div>
        <div class="cell" data-width="1" data-height="1"><span>16</span></div>
        <div class="cell" data-width="1" data-height="1"><span>17</span></div>
        <div class="cell" data-width="1" data-height="1"><span>18</span></div>
        <div class="cell" data-width="1" data-height="1"><span>19</span></div>
        <div class="cell" data-width="1" data-height="1"><span>20</span></div>
        <div class="cell" data-width="1" data-height="1"><span>21</span></div>
        <div class="cell" data-width="1" data-height="1"><span>22</span></div>
        <div class="cell" data-width="1" data-height="1"><span>23</span></div>
        <div class="cell" data-width="1" data-height="1"><span>24</span></div>
        <div class="cell" data-width="2" data-height="1"><span>25</span></div>
        <div class="cell" data-width="1" data-height="1"><span>26</span></div>
        <div class="cell" data-width="1" data-height="1"><span>27</span></div>
        <div class="cell" data-width="1" data-height="1"><span>28</span></div>
        <div class="cell" data-width="1" data-height="1"><span>29</span></div>
        <div class="cell" data-width="1" data-height="1"><span>30</span></div>
        <div class="cell" data-width="1" data-height="1"><span>31</span></div>
        <div class="cell" data-width="1" data-height="1"><span>32</span></div>
        <div class="cell" data-width="1" data-height="1"><span>33</span></div>
        <div class="cell" data-width="1" data-height="1"><span>34</span></div>
        <div class="cell" data-width="3" data-height="1"><span>35</span></div>
        <div class="cell" data-width="1" data-height="1"><span>36</span></div>
        <div class="cell" data-width="1" data-height="1"><span>37</span></div>
        <div class="cell" data-width="1" data-height="1"><span>38</span></div>
        <div class="cell" data-width="1" data-height="1"><span>39</span></div>
        <div class="cell" data-width="1" data-height="1"><span>40</span></div>
        <div class="cell" data-width="1" data-height="1"><span>41</span></div>
        <div class="cell" data-width="1" data-height="1"><span>42</span></div>
        <div class="cell" data-width="1" data-height="1"><span>43</span></div>
        <div class="cell" data-width="1" data-height="2"><span>44</span></div>
        <div class="cell" data-width="1" data-height="2"><span>45</span></div>
        <div class="cell" data-width="1" data-height="2"><span>46</span></div>
        <div class="cell" data-width="1" data-height="1"><span>47</span></div>
        <div class="cell" data-width="1" data-height="1"><span>48</span></div>
        <div class="cell" data-width="1" data-height="1"><span>49</span></div>
        <div class="cell" data-width="1" data-height="1"><span>50</span></div>
        <div class="cell" data-width="3" data-height="1"><span>51</span></div>
        <div class="cell" data-width="1" data-height="1"><span>52</span></div>
        <div class="cell" data-width="1" data-height="1"><span>53</span></div>
        <div class="cell" data-width="1" data-height="1"><span>54</span></div>
        <div class="cell" data-width="1" data-height="1"><span>55</span></div>
        <div class="cell" data-width="1" data-height="1"><span>56</span></div>
        <div class="cell" data-width="1" data-height="1"><span>57</span></div>
        <div class="cell" data-width="1" data-height="1"><span>58</span></div>
        <div class="cell" data-width="1" data-height="1"><span>59</span></div>
        <div class="cell" data-width="3" data-height="1"><span>60</span></div>
        <div class="cell" data-width="2" data-height="1"><span>61</span></div>
        <div class="cell" data-width="1" data-height="1"><span>62</span></div>
        <div class="cell" data-width="1" data-height="1"><span>63</span></div>
        <div class="cell" data-width="1" data-height="1"><span>64</span></div>
        <div class="cell" data-width="1" data-height="1"><span>65</span></div>
        <div class="cell" data-width="1" data-height="1"><span>66</span></div>
        <div class="cell" data-width="1" data-height="1"><span>67</span></div>
        <div class="cell" data-width="1" data-height="1"><span>68</span></div>
        <div class="cell" data-width="1" data-height="1"><span>69</span></div>
        <div class="cell" data-width="1" data-height="1"><span>70</span></div>
        <div class="cell" data-width="1" data-height="2"><span>71</span></div>
        <div class="cell" data-width="1" data-height="2"><span>72</span></div>
        <div class="cell" data-width="1" data-height="2"><span>73</span></div>
        <div class="cell" data-width="1" data-height="1"><span>74</span></div>
        <div class="cell" data-width="1" data-height="1"><span>75</span></div>
        <div class="cell" data-width="1" data-height="1"><span>76</span></div>
        <div class="cell" data-width="1" data-height="1"><span>77</span></div>
        <div class="cell" data-width="1" data-height="1"><span>78</span></div>
        <div class="cell" data-width="1" data-height="1"><span>79</span></div>
        <div class="cell" data-width="1" data-height="1"><span>80</span></div>
        <div class="cell" data-width="2" data-height="1"><span>81</span></div>
        <div class="cell" data-width="2" data-height="1"><span>82</span></div>
        <div class="cell" data-width="1" data-height="1"><span>83</span></div>
        <div class="cell" data-width="3" data-height="1"><span>84</span></div>
        <div class="cell" data-width="1" data-height="1"><span>85</span></div>
        <div class="cell" data-width="1" data-height="1"><span>86</span></div>
        <div class="cell" data-width="1" data-height="1"><span>87</span></div>
        <div class="cell" data-width="1" data-height="1"><span>88</span></div>
        <div class="cell" data-width="1" data-height="1"><span>89</span></div>
    </div>
</body>
</html>
